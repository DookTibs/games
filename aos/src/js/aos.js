// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.AosController = (function() {
    function AosController(ROWS, COLS) {
      this.ROWS = ROWS;
      this.COLS = COLS;
      console.log("constructing standard game controller with [" + this.ROWS + "] rows and [" + this.COLS + "] cols");
      document.body.addEventListener('touchmove', (function(evt) {
        return evt.preventDefault();
      }), false);
      this.renderer = new BoardRenderer(this, "gameboard");
      this.renderer.sizeToFit(this.ROWS, this.COLS);
      console.log("build the board...");
      this.buildBoard();
      console.log("render the board...");
      this.renderBoard();
      this.tileBank = new TileBank(this);
      this.tileBank.initUi(this.renderer.getHexSize());
      $(window).resize((function(_this) {
        return function() {
          console.log("handle resize!");
          _this.renderer.sizeToFit(_this.ROWS, _this.COLS);
          return _this.renderBoard(true);
        };
      })(this));
    }

    AosController.prototype.findRouteFromHex = function(col, row) {
      console.log("let's attempt to find a path from [" + col + "],[" + row + "]");
      this.pathfinder = new Pathfinder(this.board, this);
      return this.pathfinder.lookForPath(col, row);
    };

    AosController.prototype.getTownStyle = function() {
      return {
        stroke: "black",
        fill: "white"
      };
    };

    AosController.prototype.getLabelStyle = function() {
      var genericLabelStyle;
      return genericLabelStyle = {
        fill: "black",
        "text-anchor": "middle"
      };
    };

    AosController.debug = function(s) {
      return $("#debugger").html(s + "<br>" + $("#debugger").html());
    };

    AosController.prototype.getStyleForHexType = function(hexData) {
      var blankStyle, defaultStyle, mountainStyle, redCityStyle, t, yellowCityStyle;
      defaultStyle = {
        fill: "#659B74",
        stroke: "black"
      };
      mountainStyle = {
        fill: "grey",
        stroke: "black"
      };
      blankStyle = {
        fill: "none",
        stroke: "none"
      };
      redCityStyle = {
        stroke: "black",
        fill: "#E4473F"
      };
      yellowCityStyle = {
        stroke: "black",
        fill: "#FFFF00"
      };
      t = hexData.type;
      if (t === HexData.TYPE_MOUNTAIN) {
        return mountainStyle;
      } else if (t === HexData.TYPE_BLANK) {
        return blankStyle;
      } else if (t === HexData.TYPE_CITY) {
        if (hexData.city.color === "red") {
          return redCityStyle;
        } else if (hexData.city.color === "yellow") {
          return yellowCityStyle;
        }
      } else {
        return defaultStyle;
      }
    };

    AosController.prototype.drawHexAt = function(c, r, reset) {
      var data;
      data = this.board.getHexData(c, r);
      data.reset = reset;
      return this.renderer.renderHexAt(c, r, data);
    };

    AosController.prototype.renderBoard = function(reset) {
      var c, r, _i, _j, _ref, _ref1;
      if (reset == null) {
        reset = false;
      }
      for (r = _i = 0, _ref = this.ROWS; 0 <= _ref ? _i < _ref : _i > _ref; r = 0 <= _ref ? ++_i : --_i) {
        for (c = _j = 0, _ref1 = this.COLS; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
          this.drawHexAt(c, r, reset);
        }
      }
      return SvgUtils.bringToFront(".hex_outlines");
    };

    AosController.prototype.convertCubeToOffset = function(x, y, z) {
      var c, r;
      c = x;
      r = z + (x - (x & 1)) / 2;
      return {
        c: c,
        r: r
      };
    };

    AosController.prototype.convertOffsetToCube = function(c, r) {
      var x, y, z;
      x = c;
      z = r - (c - (c & 1)) / 2;
      y = -x - z;
      return {
        x: x,
        y: y,
        z: z
      };
    };

    AosController.prototype.convertCubeToAxial = function(x, y, z) {
      var c, r;
      c = x;
      r = z;
      return {
        c: c,
        r: r
      };
    };

    AosController.prototype.convertAxialToCube = function(c, r) {
      var x, y, z;
      x = c;
      z = r;
      y = -x - z;
      return {
        x: x,
        y: y,
        z: z
      };
    };

    AosController.prototype.pxToCoords = function(x, y) {
      var approxCoords, cubed, offset, roundedCoords;
      approxCoords = this.findApproxAxialLocation(x, y);
      cubed = this.convertAxialToCube(approxCoords.c, approxCoords.r);
      roundedCoords = this.hexRound(cubed.x, cubed.y, cubed.z);
      offset = this.convertCubeToOffset(roundedCoords.x, roundedCoords.y, roundedCoords.z);
      console.log(offset.c + "," + offset.r);
      return {
        c: offset.c,
        r: offset.r
      };
    };

    AosController.prototype.findCoords = function(pixelX, pixelY) {
      var actualOrigin, coords;
      actualOrigin = this.renderer.getHexPosition(0, 0);
      coords = this.pxToCoords(pixelX - actualOrigin.x, pixelY - actualOrigin.y);
      return console.log(coords);
    };

    AosController.prototype.handleTileBankOk = function() {
      this.board.lockInPreviewNubs(this.previewHexCoords.c, this.previewHexCoords.r);
      this.drawHexAt(this.previewHexCoords.c, this.previewHexCoords.r, true);
      this.tileBank.hideRotationUi();
      return $("#tileChooserDialog").dialog("open");
    };

    AosController.prototype.handleTileBankCancel = function() {
      this.board.clearPreviewNubs(this.previewHexCoords.c, this.previewHexCoords.r);
      this.drawHexAt(this.previewHexCoords.c, this.previewHexCoords.r, true);
      this.tileBank.hideRotationUi();
      return $("#tileChooserDialog").dialog("open");
    };

    AosController.prototype.handleTileBankPreviewRotation = function(dir) {
      this.board.rotatePreviewNubs(this.previewHexCoords.c, this.previewHexCoords.r, dir);
      return this.drawHexAt(this.previewHexCoords.c, this.previewHexCoords.r, true);
    };

    AosController.prototype.handleTileBankHexDrop = function(pixelX, pixelY, nubs) {
      var coords, firstHexOrigin, hexCoords, nub, _i, _len;
      firstHexOrigin = this.renderer.getHexPosition(0, 0);
      coords = this.pxToCoords(pixelX - firstHexOrigin.x, pixelY - firstHexOrigin.y);
      for (_i = 0, _len = nubs.length; _i < _len; _i++) {
        nub = nubs[_i];
        this.board.addPreviewNubToHex(coords.c, coords.r, new TrackNub(nub.a, nub.b));
      }
      this.drawHexAt(coords.c, coords.r, true);
      this.previewHexCoords = coords;
      hexCoords = this.renderer.getHexPosition(coords.c, coords.r);
      return this.tileBank.showRotationUi(hexCoords, this.renderer.getHexSize() * 2.2);
    };

    AosController.prototype.hexRound = function(x, y, z) {
      var rx, ry, rz, x_diff, y_diff, z_diff;
      rx = Math.round(x);
      ry = Math.round(y);
      rz = Math.round(z);
      x_diff = Math.abs(rx - x);
      y_diff = Math.abs(ry - y);
      z_diff = Math.abs(rz - z);
      if (x_diff > y_diff && x_diff > z_diff) {
        rx = -ry - rz;
      } else if (y_diff > z_diff) {
        ry = -rx - rz;
      } else {
        rz = -rx - ry;
      }
      return {
        x: rx,
        y: ry,
        z: rz
      };
    };

    AosController.prototype.findApproxAxialLocation = function(x, y) {
      var c, r, size;
      size = this.renderer.getHexSize();
      c = 2 / 3 * x / size;
      r = (-1 / 3 * x + 1 / 3 * Math.sqrt(3) * y) / size;
      return {
        c: c,
        r: r
      };
    };

    return AosController;

  })();

  window.BarbadosAosController = (function(_super) {
    __extends(BarbadosAosController, _super);

    function BarbadosAosController() {
      BarbadosAosController.__super__.constructor.call(this, 10, 8);
    }

    BarbadosAosController.prototype.buildBoard = function() {
      var blanks, color, coord, coords, data, mountains, rowCol, side, tm, townData, towns, typeMappers, _i, _j, _k, _len, _len1, _len2;
      this.board = new AosBoard(this.ROWS, this.COLS);
      mountains = ["1,0", "1,1", "1,2", "1,3", "1,4", "1,5", "2,3", "2,4", "2,5", "2,6", "3,3", "3,4", "3,5", "3,6", "4,5", "4,6", "5,5"];
      blanks = ["0,8", "0,9", "1,9", "2,0", "2,9", "3,0", "3,1", "3,9", "4,0", "4,1", "4,2", "4,3", "5,0", "5,1", "5,2", "5,3", "5,9", "6,0", "6,1", "6,2", "6,3", "6,4", "6,9", "7,0", "7,1", "7,2", "7,3", "7,4", "7,8", "7,9"];
      towns = ["0,2,Speightstown", "0,4,Holetown", "1,8,South Coast", "3,2,Lakes Beach", "5,6,Brighton"];
      typeMappers = [
        {
          coords: mountains,
          type: HexData.TYPE_MOUNTAIN
        }, {
          coords: blanks,
          type: HexData.TYPE_BLANK
        }
      ];
      for (_i = 0, _len = typeMappers.length; _i < _len; _i++) {
        tm = typeMappers[_i];
        coords = tm.coords;
        for (_j = 0, _len1 = coords.length; _j < _len1; _j++) {
          coord = coords[_j];
          rowCol = coord.split(",");
          this.board.setHexType(parseInt(rowCol[0]), parseInt(rowCol[1]), tm.type);
        }
      }
      for (_k = 0, _len2 = towns.length; _k < _len2; _k++) {
        townData = towns[_k];
        data = townData.split(",");
        this.board.setHexTown(parseInt(data[0]), parseInt(data[1]), new Town(data[2]));
      }
      color = "yellow";
      side = "white";
      this.board.setHexCity(0, 0, new City("North Point", color, {
        die: 1,
        side: side
      }));
      this.board.setHexCity(4, 4, new City("Bathsheba", color, {
        die: 2,
        side: side
      }));
      this.board.setHexCity(6, 5, new City("Bell Point", color, {
        die: 3,
        side: side
      }));
      this.board.setHexCity(0, 7, new City("Bridgetown", color, {
        die: 4,
        side: side
      }));
      this.board.setHexCity(4, 9, new City("Oistins", color, {
        die: 5,
        side: side
      }));
      this.board.setHexCity(7, 7, new City("Crane Beach", color, {
        die: 6,
        side: side
      }));
      this.board.addNubToHex(1, 6, new TrackNub(5, 2));
      this.board.addNubToHex(2, 6, new TrackNub(5, 6));
      this.board.addNubToHex(1, 5, new TrackNub(3, 4));
      this.board.addNubToHex(1, 5, new TrackNub(6, 1));
      this.board.addNubToHex(1, 6, new TrackNub(1, 4));
      this.board.addNubToHex(1, 7, new TrackNub(1, 4));
      this.board.addNubToHex(1, 8, new TrackNub(1, 2));
      this.board.addNubToHex(2, 8, new TrackNub(5, 2));
      this.board.addNubToHex(3, 7, new TrackNub(5, 2));
      this.board.addNubToHex(4, 7, new TrackNub(5, 2));
      this.board.addNubToHex(5, 6, new TrackNub(5, 3));
      this.board.addNubToHex(6, 7, new TrackNub(6, 4));
      this.board.addNubToHex(6, 8, new TrackNub(1, 2));
      this.board.addNubToHex(5, 6, new TrackNub(0, 1));
      this.board.addNubToHex(5, 5, new TrackNub(4, 2));
      this.board.addNubToHex(6, 6, new TrackNub(1, 6));
      this.board.addNubToHex(5, 5, new TrackNub(6, 3));
      this.board.addNubToHex(4, 5, new TrackNub(1, 3));
      this.board.addNubToHex(1, 7, new TrackNub(6, 3));
      this.board.addNubToHex(2, 8, new TrackNub(6, 3));
      this.board.addNubToHex(3, 8, new TrackNub(6, 3));
      this.board.addCubeToHex(0, 7, new Cube(Cube.COLOR_PURPLE));
      this.board.addCubeToHex(4, 9, new Cube(Cube.COLOR_BLUE));
      return this.board.debugBoard();
    };

    return BarbadosAosController;

  })(window.AosController);

  window.Pathfinder = (function() {
    function Pathfinder(board, controller) {
      this.board = board;
      this.controller = controller;
    }

    Pathfinder.prototype.pathSearch = function(col, row, fromDir, depth, maxLinks, traversalDataDuper) {
      var currHex, dupe, indent, neighbor, nextDir, nub, potentialExits, traversalData, z, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _results;
      if (maxLinks == null) {
        maxLinks = 6;
      }
      if (traversalDataDuper == null) {
        traversalDataDuper = null;
      }
      traversalData = {
        numLinks: 0,
        visitedPopulationCenterHexes: [],
        nubs: []
      };
      if (traversalDataDuper !== null) {
        traversalData.numLinks = traversalDataDuper.numLinks;
        _ref = traversalDataDuper.visitedPopulationCenterHexes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dupe = _ref[_i];
          traversalData.visitedPopulationCenterHexes.push(dupe);
        }
        _ref1 = traversalDataDuper.nubs;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          nub = _ref1[_j];
          traversalData.nubs.push(nub);
        }
      }
      indent = "";
      for (z = _k = 1; 1 <= depth ? _k <= depth : _k >= depth; z = 1 <= depth ? ++_k : --_k) {
        indent += "\t";
      }
      if (depth > 20) {
        console.log(indent + "short circuiting!");
        return;
      }
      currHex = this.board.getHexData(col, row);
      console.log(indent + "examining [" + col + "," + row + "]");
      if (currHex === void 0 || currHex.type === HexData.TYPE_BLANK) {
        console.log(indent + "it's blank; stop");
        return;
      } else if (currHex.type === HexData.TYPE_CITY) {
        if (depth > 2) {
          traversalData.numLinks++;
          console.log("!!!!!!!! RE REACHED [" + currHex.city.name + "] in [" + traversalData.numLinks + " links");
          this.foundPaths.push(traversalData);
          return;
        }
        potentialExits = [1, 2, 3, 4, 5, 6];
      } else if (currHex.type === HexData.TYPE_TOWN) {
        potentialExits = currHex.getNubEnds();
        console.log("!!!!! POTENTIAL EXITS FROM TOWN [" + potentialExits + "]...");
        traversalData.numLinks++;
        console.log("now [" + traversalData.numLinks + "] links");
      } else {
        potentialExits = [currHex.getNubEnd(fromDir)];
        console.log(indent + ("" + fromDir + " leads to ") + currHex.getNubEnd(fromDir) + "...");
      }
      _results = [];
      for (_l = 0, _len2 = potentialExits.length; _l < _len2; _l++) {
        nextDir = potentialExits[_l];
        if (nextDir !== null && nextDir !== fromDir) {
          console.log(indent + ("leave on " + nextDir + "..."));
          traversalData.nubs.push(new TrackNub(fromDir, nextDir));
          neighbor = AosBoard.getNeighborColRow(col, row, nextDir);
          _results.push(this.pathSearch(neighbor.col, neighbor.row, AosBoard.getOppositeSide(nextDir), depth + 1, maxLinks, traversalData));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Pathfinder.prototype.lookForPath = function(col, row) {
      console.log("pathfinder looking for path from [" + col + "],[" + row + "]...");
      this.foundPaths = [];
      this.pathSearch(col, row, -1, 0);
      console.log("--- ALL DONE ---");
      return console.log(this.foundPaths);
    };

    return Pathfinder;

  })();

  window.PuertoRicoAosController = (function(_super) {
    __extends(PuertoRicoAosController, _super);

    function PuertoRicoAosController() {
      PuertoRicoAosController.__super__.constructor.call(this, 5, 13);
    }

    PuertoRicoAosController.prototype.buildBoard = function() {
      var blanks, coord, coords, data, mountains, rowCol, tm, townData, towns, typeMappers, _i, _j, _k, _len, _len1, _len2;
      this.board = new AosBoard(this.ROWS, this.COLS);
      mountains = ["1,3", "2,2", "2,3", "3,0", "3,1", "3,2", "4,1", "4,3", "5,0", "5,1", "5,2", "6,2", "6,3", "7,2", "7,3", "8,2", "9,2", "10,2"];
      blanks = ["0,0", "1,4", "3,4", "5,4", "6,4", "7,4", "9,4", "10,4", "11,3", "11,4", "12,2", "12,3", "12,4"];
      towns = ["0,2,Mayaguez", "0,4,Cabo Rojo", "1,0,Aguadilla", "4,0,Arecibo", "4,2,Utuado", "5,3,Ponce", "8,1,Bayamon", "8,3,Cayey", "9,1,Caguas", "11,2,Humacao", "12,0,Luquillo"];
      typeMappers = [
        {
          coords: mountains,
          type: HexData.TYPE_MOUNTAIN
        }, {
          coords: blanks,
          type: HexData.TYPE_BLANK
        }
      ];
      for (_i = 0, _len = typeMappers.length; _i < _len; _i++) {
        tm = typeMappers[_i];
        coords = tm.coords;
        for (_j = 0, _len1 = coords.length; _j < _len1; _j++) {
          coord = coords[_j];
          rowCol = coord.split(",");
          this.board.setHexType(parseInt(rowCol[0]), parseInt(rowCol[1]), tm.type);
        }
      }
      for (_k = 0, _len2 = towns.length; _k < _len2; _k++) {
        townData = towns[_k];
        data = townData.split(",");
        this.board.setHexTown(parseInt(data[0]), parseInt(data[1]), new Town(data[2]));
      }
      this.board.setHexCity(9, 0, new City("San Juan", "red", null));
      this.board.debugBoard();
      return console.log("done!");
    };

    return PuertoRicoAosController;

  })(window.AosController);

  window.AosBoard = (function() {
    AosBoard.DIR_NO = 1;

    AosBoard.DIR_NE = 2;

    AosBoard.DIR_SE = 3;

    AosBoard.DIR_SO = 4;

    AosBoard.DIR_SW = 5;

    AosBoard.DIR_NW = 6;

    function AosBoard(rows, cols, defaultType) {
      var c, r, rowData, _i, _j;
      if (defaultType == null) {
        defaultType = HexData.TYPE_NORMAL;
      }
      this.boardStorage = [];
      for (r = _i = 0; 0 <= rows ? _i <= rows : _i >= rows; r = 0 <= rows ? ++_i : --_i) {
        rowData = [];
        for (c = _j = 0; 0 <= cols ? _j <= cols : _j >= cols; c = 0 <= cols ? ++_j : --_j) {
          console.log("loop " + r + ", " + c);
          rowData.push(new HexData(r, c, defaultType));
        }
        this.boardStorage.push(rowData);
      }
    }

    AosBoard.getOppositeSide = function(dir) {
      if (dir === AosBoard.DIR_NO) {
        return AosBoard.DIR_SO;
      } else if (dir === AosBoard.DIR_NE) {
        return AosBoard.DIR_SW;
      } else if (dir === AosBoard.DIR_NW) {
        return AosBoard.DIR_SE;
      } else if (dir === AosBoard.DIR_SO) {
        return AosBoard.DIR_NO;
      } else if (dir === AosBoard.DIR_SE) {
        return AosBoard.DIR_NW;
      } else if (dir === AosBoard.DIR_SW) {
        return AosBoard.DIR_NE;
      }
    };

    AosBoard.getNeighborColRow = function(col, row, dir) {
      var nCol, nRow;
      nCol = col;
      nRow = row;
      if (dir === AosBoard.DIR_NO) {
        nRow--;
      } else if (dir === AosBoard.DIR_SO) {
        nRow++;
      } else {
        if (col % 2 === 1) {
          if (dir === AosBoard.DIR_NE) {
            nCol++;
          } else if (dir === AosBoard.DIR_SE) {
            nCol++;
            nRow++;
          } else if (dir === AosBoard.DIR_SW) {
            nCol--;
            nRow++;
          } else if (dir === AosBoard.DIR_NW) {
            nCol--;
          }
        } else {
          if (dir === AosBoard.DIR_NE) {
            nRow--;
            nCol++;
          } else if (dir === AosBoard.DIR_SE) {
            nCol++;
          } else if (dir === AosBoard.DIR_SW) {
            nCol--;
          } else if (dir === AosBoard.DIR_NW) {
            nCol--;
            nRow--;
          }
        }
      }
      return {
        row: nRow,
        col: nCol
      };
    };

    AosBoard.prototype.setHexTown = function(col, row, town) {
      var hd;
      hd = this.getHexData(col, row);
      return hd.setTown(town);
    };

    AosBoard.prototype.setHexCity = function(col, row, city) {
      var hd;
      hd = this.getHexData(col, row);
      return hd.setCity(city);
    };

    AosBoard.prototype.setHexType = function(col, row, type) {
      var hd;
      console.log("get data for [" + col + "],[" + row + "], [" + type + "]");
      hd = this.getHexData(col, row);
      return hd.type = type;
    };

    AosBoard.prototype.addNubToHex = function(col, row, nub) {
      var hd;
      hd = this.getHexData(col, row);
      return hd.addNub(nub);
    };

    AosBoard.prototype.addCubeToHex = function(col, row, cube) {
      return this.getHexData(col, row).addCube(cube);
    };

    AosBoard.prototype.clearPreviewNubs = function(col, row) {
      var hd;
      hd = this.getHexData(col, row);
      return hd.clearPreviewNubs();
    };

    AosBoard.prototype.lockInPreviewNubs = function(col, row) {
      var hd;
      hd = this.getHexData(col, row);
      return hd.lockInPreviewNubs();
    };

    AosBoard.prototype.addPreviewNubToHex = function(col, row, nub) {
      var hd;
      hd = this.getHexData(col, row);
      return hd.addPreviewNub(nub);
    };

    AosBoard.prototype.rotatePreviewNubs = function(col, row, dir) {
      var hd;
      hd = this.getHexData(col, row);
      return hd.rotatePreviewNubs(dir);
    };

    AosBoard.prototype.getHexData = function(col, row) {
      var hd;
      hd = this.boardStorage[row][col];
      return hd;
    };

    AosBoard.prototype.debugBoard = function() {
      var c, hd, r, row, rowRep, slot, _i, _j, _len, _len1, _ref, _results;
      console.log("board structure:");
      _ref = this.boardStorage;
      _results = [];
      for (r = _i = 0, _len = _ref.length; _i < _len; r = ++_i) {
        row = _ref[r];
        rowRep = "";
        for (c = _j = 0, _len1 = row.length; _j < _len1; c = ++_j) {
          slot = row[c];
          hd = this.getHexData(c, r);
          if (hd.town !== null) {
            rowRep += "[" + hd.town.name.substr(0, 5) + "]\t";
          } else if (hd.city !== null) {
            rowRep += "[" + hd.city.name.substr(0, 5) + "]\t";
          } else {
            rowRep += "[" + hd.type.substr(0, 5) + "]\t";
          }
        }
        _results.push(console.log(rowRep));
      }
      return _results;
    };

    return AosBoard;

  })();

  window.City = (function() {
    function City(name, color, productionData) {
      this.name = name;
      this.color = color;
      console.log("building city with [" + productionData + "]");
    }

    return City;

  })();

  window.Cube = (function() {
    Cube.COLOR_RED = "#FF0000";

    Cube.COLOR_BLUE = "#0000FF";

    Cube.COLOR_BLACK = "#000000";

    Cube.COLOR_PURPLE = "#FF00FF";

    Cube.COLOR_YELLOW = "#00FFFF";

    function Cube(color) {
      this.color = color;
    }

    return Cube;

  })();

  window.HexData = (function() {
    HexData.TYPE_NORMAL = "norm";

    HexData.TYPE_BLANK = "blank";

    HexData.TYPE_TOWN = "town";

    HexData.TYPE_CITY = "city";

    HexData.TYPE_MOUNTAIN = "mtn";

    function HexData(r, c, t) {
      this.id = "" + c + "," + r;
      this.type = t;
      this.town = null;
      this.city = null;
      this.nubs = [];
      this.previewNubs = [];
      this.cubes = [];
    }

    HexData.prototype.setTown = function(d) {
      this.town = d;
      return this.type = HexData.TYPE_TOWN;
    };

    HexData.prototype.setCity = function(d) {
      this.city = d;
      return this.type = HexData.TYPE_CITY;
    };

    HexData.prototype.addNub = function(nub) {
      if (this.town === null && this.city === null) {
        return this.nubs.push(nub);
      } else if (this.town !== null) {
        if (nub.sideA === 0 || nub.sideB === 0) {
          return this.nubs.push(nub);
        } else {
          this.nubs.push(new TrackNub(0, nub.sideA));
          return this.nubs.push(new TrackNub(0, nub.sideB));
        }
      }
    };

    HexData.prototype.addPreviewNub = function(nub) {
      return this.previewNubs.push(nub);
    };

    HexData.prototype.clearPreviewNubs = function() {
      return this.previewNubs = [];
    };

    HexData.prototype.lockInPreviewNubs = function() {
      this.nubs = this.previewNubs;
      return this.previewNubs = [];
    };

    HexData.prototype.addCube = function(cube) {
      return this.cubes.push(cube);
    };

    HexData.prototype.getNubEnds = function() {
      var nub, rv, _i, _len, _ref;
      rv = [];
      _ref = this.nubs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        nub = _ref[_i];
        if (nub.sideA !== 0) {
          rv.push(nub.sideA);
        }
        if (nub.sideB !== 0) {
          rv.push(nub.sideB);
        }
      }
      return rv;
    };

    HexData.prototype.getNubEnd = function(nubStart) {
      var nub, _i, _len, _ref;
      _ref = this.nubs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        nub = _ref[_i];
        if (nub.sideA === nubStart) {
          return nub.sideB;
        } else if (nub.sideB === nubStart) {
          return nub.sideA;
        }
      }
      return null;
    };

    HexData.prototype.removeCube = function(cube) {
      var c, idx, _i, _len, _ref, _results;
      _ref = this.cubes;
      _results = [];
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        c = _ref[idx];
        if (c.color === cube.color) {
          this.cubes.splice(idx, 1);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    HexData.prototype.rotatePreviewNubs = function(dir) {
      var nub, _i, _len, _ref, _results;
      _ref = this.previewNubs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        nub = _ref[_i];
        _results.push(nub.rotate(dir));
      }
      return _results;
    };

    return HexData;

  })();

  window.Town = (function() {
    function Town(name) {
      this.name = name;
      console.log("building town with name [" + this.name + "]");
    }

    return Town;

  })();

  window.TrackNub = (function() {
    function TrackNub(sideA, sideB) {
      this.sideA = sideA;
      this.sideB = sideB;
    }

    TrackNub.prototype.equals = function(otherNub) {
      if (this.sideA === otherNub.sideA && this.sideB === otherNub.sideB) {
        return true;
      } else if (this.sideB === otherNub.sideA && this.sideA === otherNub.sideB) {
        return true;
      } else {
        return false;
      }
    };

    TrackNub.prototype.stayInBounds = function(x) {
      if (x > 6) {
        return x % 6;
      } else if (x < 1) {
        return 6 - (x % 6);
      } else {
        return x;
      }
    };

    TrackNub.prototype.rotate = function(dir) {
      this.sideA += dir;
      this.sideB += dir;
      this.sideA = this.stayInBounds(this.sideA);
      return this.sideB = this.stayInBounds(this.sideB);
    };

    return TrackNub;

  })();

  window.HexUtils = (function() {
    function HexUtils() {}

    HexUtils.getGentleCurveAngles = function(sideA, sideB) {
      var base, frontHalfOnly, frontHalfOnlyAdjustment, rv, sidesApart;
      sidesApart = Math.abs(sideA - sideB);
      frontHalfOnly = true;

      /*
      if frontHalfOnly
        frontHalfOnlyAdjustment = 30
      else
       */
      frontHalfOnlyAdjustment = 0;
      if (sidesApart === 2) {
        if (sideA < sideB) {
          base = (sideA * 60) + 120;
          rv = [base - frontHalfOnlyAdjustment, base - 60];
        } else {
          base = (sideB * 60) + 120;
          rv = [base - 60, base - frontHalfOnlyAdjustment];
        }
      } else if (sidesApart === 4) {
        if (sideA < sideB) {
          base = (sideA - 1) * 60;
          rv = [base, base + 60 - frontHalfOnlyAdjustment];
        } else {
          base = (sideB - 1) * 60;
          rv = [base + 60 - frontHalfOnlyAdjustment, base];
        }
      }
      return rv;
    };

    HexUtils.getSharpCurveAngles = function(sideA, sideB) {
      var base, rv, sidesApart;
      sidesApart = Math.abs(sideA - sideB);
      if (sidesApart === 1) {
        if (sideA < sideB) {
          base = sideA * 60;
          rv = [base + 120, base];
        } else {
          base = sideB * 60;
          rv = [base, base + 120];
        }
      } else if (sidesApart === 5) {
        if (sideA < sideB) {
          rv = [0, 120];
        } else {
          rv = [120, 0];
        }
      }
      return rv;
    };

    HexUtils.getSharedSidePoint = function(sideAPoints, sideBPoints) {
      if (sideAPoints[0].x === sideBPoints[1].x && sideAPoints[0].y === sideBPoints[1].y) {
        return sideAPoints[0];
      } else {
        return sideAPoints[1];
      }
    };

    return HexUtils;

  })();

  window.SvgUtils = (function() {
    function SvgUtils() {}

    SvgUtils.generateHexPoints = function(center, size) {
      var angle, i, loopX, loopY, rv, _i;
      rv = [];
      for (i = _i = 0; _i <= 5; i = ++_i) {
        angle = 2 * Math.PI / 6 * i;
        loopX = center.x + size * Math.cos(angle);
        loopY = center.y + size * Math.sin(angle);
        rv.push({
          x: loopX,
          y: loopY
        });
      }
      return rv;
    };

    SvgUtils.createPathFromPoints = function(pts, closePath) {
      var i, pt, rv, _i, _len;
      if (closePath == null) {
        closePath = true;
      }
      if (closePath) {
        pts.push(pts[0]);
      }
      rv = "";
      for (i = _i = 0, _len = pts.length; _i < _len; i = ++_i) {
        pt = pts[i];
        rv += i === 0 ? "M" : "L";
        rv += pt.x + " " + pt.y;
      }
      return rv;
    };

    SvgUtils.drawCircle = function(canvas, center, radius, attrs) {
      var c;
      console.log("DRAWING CIRCLE!");
      c = canvas.circle(center.x, center.y, radius);
      c.attr(attrs);
      return c;
    };

    SvgUtils.drawText = function(canvas, midpoint, text, attrs) {
      var t;
      t = canvas.text(midpoint.x, midpoint.y, text);
      t.attr(attrs);
      return t;
    };

    SvgUtils.drawRectangle = function(canvas, origin, width, height, attrs) {
      var r;
      console.log("drawing rect " + origin.x + ", " + origin.y + ", " + width + ", " + height);
      r = canvas.rect(origin.x, origin.y, width, height);
      r.attr(attrs);
      return r;
    };

    SvgUtils.drawCenteredRectangle = function(canvas, origin, width, height, attrs) {
      var r;
      console.log("drawing centered rect " + origin.x + ", " + origin.y + ", " + width + ", " + height);
      r = canvas.rect(origin.x - width / 2, origin.y - height / 2, width, height);
      r.attr(attrs);
      return r;
    };

    SvgUtils.drawHex = function(canvas, center, size, attrs) {
      var hex, path, pts;
      pts = SvgUtils.generateHexPoints(center, size);
      path = SvgUtils.createPathFromPoints(pts);
      hex = canvas.path(path);
      hex.attr(attrs);
      return hex;
    };

    SvgUtils.getMidPoint = function(pointA, pointB) {
      return {
        x: (pointA.x + pointB.x) / 2,
        y: (pointA.y + pointB.y) / 2
      };
    };

    SvgUtils.getCoordsOfCircleAngle = function(center, radius, angle) {
      var angleInRads, x, y;
      angleInRads = Snap.rad(angle);
      x = center.x + radius * Math.cos(angleInRads);
      y = center.y + radius * Math.sin(angleInRads);
      return {
        x: x,
        y: y
      };
    };

    SvgUtils.createArcPath = function(center, radius, startAngle, endAngle) {
      var arcPath, endCoords, largeArcFlag, startCoords, sweepFlag, xAxisRot;
      startCoords = SvgUtils.getCoordsOfCircleAngle(center, radius, startAngle);
      endCoords = SvgUtils.getCoordsOfCircleAngle(center, radius, endAngle);
      xAxisRot = 0;
      largeArcFlag = 0;
      sweepFlag = 1;
      if (endAngle < startAngle) {
        sweepFlag = 0;
      }
      arcPath = "M" + startCoords.x + "," + startCoords.y;
      arcPath += " A" + radius + "," + radius + " " + xAxisRot + " " + largeArcFlag + "," + sweepFlag;
      arcPath += " " + endCoords.x + "," + endCoords.y;
      return arcPath;
    };

    SvgUtils.mergePaths = function(paths) {
      var p, rv, _i, _len;
      rv = "";
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        p = paths[_i];
        rv += p;
      }
      return rv;
    };

    SvgUtils.animateAlongPath = function(canvas, item, paths) {
      var bbox, comboPath, easeFxn, initialPos, mergedPaths;
      mergedPaths = SvgUtils.mergePaths(paths);
      console.log("merged: [" + mergedPaths + "]");
      comboPath = canvas.path(mergedPaths);
      comboPath.attr({
        fill: "none",
        stroke: "none"
      });

      /*
      item.attr({cx: 100})
      console.log("item is at [" + item.attr("cy") + "]/[" + item.attr("y") + "]")
      item.attr({y: 100})
      console.log("NOW item is at [" + item.attr("cy") + "]/[" + item.attr("y") + "]")
      return
       */
      easeFxn = mina.easeinout;
      bbox = item.getBBox();
      initialPos = {
        x: bbox.x,
        y: bbox.y
      };
      return Snap.animate(0, comboPath.getTotalLength(), ((function(_this) {
        return function(value) {
          var movePoint;
          movePoint = comboPath.getPointAtLength(value);
          return item.attr({
            x: parseInt(movePoint.x - bbox.width / 2),
            y: parseInt(movePoint.y - bbox.height / 2)
          });
        };
      })(this)), 2000, easeFxn, ((function(_this) {
        return function() {
          return console.log("finished animation");
        };
      })(this)));
    };

    SvgUtils.bringToFront = function(selector) {
      var el, elements, i, parent, _i, _ref, _results;
      console.log("bringing [" + selector + "] to front");
      elements = $(selector);
      _results = [];
      for (i = _i = 0, _ref = elements.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        el = elements.eq(i);
        parent = el.parent();
        _results.push(el.detach().appendTo(parent));
      }
      return _results;
    };

    return SvgUtils;

  })();

  window.BoardRenderer = (function() {
    BoardRenderer.prototype.SIDE_PADDING = 20;

    function BoardRenderer(controller, snapCanvasId) {
      this.controller = controller;
      this.snapCanvasId = snapCanvasId;
      console.log("now snap canvas is [" + this.snapCanvasId + "]");
      this.snapCanvas = Snap("#" + this.snapCanvasId);
      this.jqCanvas = $("#" + this.snapCanvasId);
    }

    BoardRenderer.prototype.sizeToFit = function(rows, cols) {
      var hVal, vVal, vValTmp;
      console.log("size hexes to fit - dimensions are [" + this.jqCanvas.width() + "] x [" + this.jqCanvas.height() + "]");
      hVal = (this.jqCanvas.width() - (this.SIDE_PADDING * 2)) / ((.75 * (cols - 1)) + 1);
      if (cols === 1) {
        vValTmp = (this.jqCanvas.height() - (this.SIDE_PADDING * 2)) / (.5 * rows);
      } else {
        vValTmp = (this.jqCanvas.height() - (this.SIDE_PADDING * 2)) / ((.5 * rows) + .25);
      }
      vVal = vValTmp / (Math.sqrt(3));
      return this.setHexSize(Math.min(hVal, vVal) / 2);
    };

    BoardRenderer.prototype.setHexSize = function(_hexSize) {
      this._hexSize = _hexSize;
      if (this._hexSize !== -1) {
        this.hexWidth = this.getHexSize() * 2;
        this.horizDistance = 3 / 4 * this.hexWidth;
        return this.hexHeight = Math.sqrt(3) / 2 * this.hexWidth;
      }
    };

    BoardRenderer.prototype.getHexSize = function() {
      return this._hexSize;
    };

    BoardRenderer.prototype.getHexPosition = function(col, row) {
      var centerX, centerY, xOffset, yOffset;
      xOffset = this.getHexSize() + this.SIDE_PADDING;
      yOffset = this.hexHeight / 2 + this.SIDE_PADDING;
      centerX = xOffset + (col * this.horizDistance);
      centerY = yOffset + (row * this.hexHeight) + (col % 2 === 1 ? this.hexHeight / 2 : 0);
      return {
        x: centerX,
        y: centerY
      };
    };

    BoardRenderer.prototype.generateHexSidePoints = function(col, row, side) {
      var center, pts;
      if (side !== -1 && (side < 1 || side > 6)) {
        console.log("invalid side passed in");
        return;
      }
      center = this.getHexPosition(col, row);
      pts = SvgUtils.generateHexPoints(center, this.getHexSize());
      if (side !== -1) {
        if (side === AosBoard.DIR_NO) {
          pts = [pts[4], pts[5]];
        } else if (side === AosBoard.DIR_NE) {
          pts = [pts[5], pts[0]];
        } else {
          pts = pts.slice(side - 3, +(side - 2) + 1 || 9e9);
        }
      }
      return pts;
    };


    /*
    testAllTrack: () ->
      rev = false
      testData = [
        [1, 0, 6, 3]
        [2, 1, 6, 4]
        [2, 2, 1, 5]
        [1, 2, 2, 3]
        [2, 3, 6, 1]
        [2, 2, 4, 2]
        [3, 1, 5, 1]
        [3, 0, 4, 3]
      ]
    
      gentleData = [
        [2, 1, 4, 2, rev]
        [3, 0, 5, 3, rev]
        [4, 1, 6, 4, rev]
        [4, 2, 1, 5, rev]
        [3, 2, 2, 6, rev]
        [2, 2, 3, 1, rev]
      ]
    
      sharpData = [
        [2, 1, 3, 4, rev]
        [3, 1, 5, 6, rev]
        [2, 2, 1, 2, rev]
    
        [4, 1, 2, 3, rev]
        [5, 0, 4, 5, rev]
        [5, 1, 1, 6, rev]
      ]
    
      for d in testData
        if (d[4])
          @drawTrackNub(d[0], d[1], d[3], d[2])
        else
          @drawTrackNub(d[0], d[1], d[2], d[3])
     */

    BoardRenderer.prototype.getBetweenSide = function(a, b) {
      var _ref;
      _ref = [Math.min(a, b), Math.max(a, b)], a = _ref[0], b = _ref[1];
      if (b - a === 2) {
        return b - 1;
      } else if (b - a === 4) {
        return (b % 6) + 1;
      }
    };

    BoardRenderer.prototype.getPathForSideToSide = function(col, row, fromSide, toSide) {
      var angles, betweenSide, fromPoints, hexCenter, n, neighborCenter, originPoint, path, pts, sidesApart, toPoints;
      sidesApart = Math.abs(fromSide - toSide);
      fromPoints = this.generateHexSidePoints(col, row, fromSide);
      toPoints = this.generateHexSidePoints(col, row, toSide);
      if (fromSide === 0 || toSide === 0) {
        hexCenter = this.getHexPosition(col, row);
        if (fromSide === 0) {
          console.log("fromside==0, toside=[" + toSide + "],toPoints:");
          console.log(toPoints);
          path = SvgUtils.createPathFromPoints([
            {
              x: hexCenter.x,
              y: hexCenter.y
            }, SvgUtils.getMidPoint(toPoints[0], toPoints[1])
          ]);
        } else {
          path = SvgUtils.createPathFromPoints([
            SvgUtils.getMidPoint(fromPoints[0], fromPoints[1]), {
              x: hexCenter.x,
              y: hexCenter.y
            }
          ]);
        }
      } else if (sidesApart === 3) {
        pts = [SvgUtils.getMidPoint(fromPoints[0], fromPoints[1]), SvgUtils.getMidPoint(toPoints[0], toPoints[1])];
        path = SvgUtils.createPathFromPoints(pts, false);
      } else if (sidesApart === 2 || sidesApart === 4) {
        betweenSide = this.getBetweenSide(fromSide, toSide);
        n = AosBoard.getNeighborColRow(col, row, betweenSide);
        neighborCenter = this.getHexPosition(n.col, n.row);
        angles = HexUtils.getGentleCurveAngles(fromSide, toSide);
        path = SvgUtils.createArcPath(neighborCenter, this.getHexSize() * 1.5, angles[0], angles[1]);
      } else if (sidesApart === 1 || sidesApart === 5) {
        originPoint = HexUtils.getSharedSidePoint(fromPoints, toPoints);
        angles = HexUtils.getSharpCurveAngles(fromSide, toSide);
        path = SvgUtils.createArcPath(originPoint, this.getHexSize() / 2, angles[0], angles[1]);
      }
      return path;
    };

    BoardRenderer.prototype.drawTrackNub = function(col, row, fromSide, toSide, color) {
      var path, track;
      if (color == null) {
        color = "black";
      }
      path = this.getPathForSideToSide(col, row, fromSide, toSide);
      if (path) {
        track = this.snapCanvas.path(path);
        return track.attr({
          stroke: color,
          "stroke-width": 4,
          fill: "none",
          "stroke-linecap": "butt"
        });
      } else {
        return console.log("invalid sides passed to drawTrackNub");
      }
    };

    BoardRenderer.prototype.paintThickBorder = function(col, row, thickness, side) {
      var border, path, pts;
      if (side == null) {
        side = -1;
      }
      pts = this.generateHexSidePoints(col, row, side);
      path = SvgUtils.createPathFromPoints(pts);
      border = this.snapCanvas.path(path);
      border.attr({
        stroke: "black",
        "stroke-width": thickness,
        fill: "none"
      });
      return border;
    };

    BoardRenderer.prototype.paintDashedBorder = function(col, row, side) {
      var border, clearer, path, pts;
      if (side == null) {
        side = -1;
      }
      pts = this.generateHexSidePoints(col, row, side);
      path = SvgUtils.createPathFromPoints(pts);
      clearer = this.snapCanvas.path(path);
      clearer.attr({
        stroke: "#659B74",
        "stroke-width": 2.3,
        fill: "none"
      });
      border = this.snapCanvas.path(path);
      return border.attr({
        stroke: "black",
        "stroke-width": 5,
        fill: "none",
        "stroke-dasharray": "5,5"
      });
    };


    /*
      fakeCenter = @getHexPosition(1, 0)
      fakeCube = SvgUtils.drawCenteredRectangle(@snapCanvas, {x: fakeCenter.x, y: fakeCenter.y }, 20, 20, {stroke: "black", fill: "purple", id:"fakeCube"})
       * fakeCube = @drawCenteredRectangle({x: 0, y: 0 }, 40, 40, {stroke: "black", fill: "purple"})
      foo = (() =>
        console.log "animate the cube!"
        cb = $("#fakeCube")
        par = cb.parent()
        cb.detach().appendTo(par)
        SvgUtils.animateAlongPath(@snapCanvas, fakeCube, [
                                    @getPathForSideToSide(1, 0, 6, 3)
                                    @getPathForSideToSide(2, 1, 6, 4)
                                    @getPathForSideToSide(2, 2, 1, 5)
                                    @getPathForSideToSide(1, 2, 2, 3)
                                    @getPathForSideToSide(2, 3, 6, 1)
                                    @getPathForSideToSide(2, 2, 4, 2)
                                    @getPathForSideToSide(3, 1, 5, 1)
                                    @getPathForSideToSide(3, 0, 4, 3)
                                    ])
      )
       * foo()
      fakeCube.click(foo)
       * setTimeout(foo, 500)
     */

    BoardRenderer.prototype.renderTown = function(center, town) {
      var t;
      SvgUtils.drawCircle(this.snapCanvas, center, this.getHexSize() * .6, this.controller.getTownStyle());
      t = SvgUtils.drawText(this.snapCanvas, {
        x: center.x,
        y: center.y + this.hexHeight / 2 - (this.hexHeight * .05)
      }, town.name, this.controller.getLabelStyle());
      return t.attr("font-size", this.hexHeight * .14);
    };

    BoardRenderer.prototype.drawCube = function(center, col, row, cube) {
      var thisHook;
      cube = SvgUtils.drawCenteredRectangle(this.snapCanvas, {
        x: center.x,
        y: center.y
      }, 20, 20, {
        stroke: "black",
        fill: cube.color,
        id: "fakeCube"
      });
      thisHook = this;
      return cube.click(function() {
        return thisHook.controller.findRouteFromHex(col, row);
      });
    };

    BoardRenderer.prototype.renderCity = function(center, col, row, city) {
      var border, boxHeight, boxWidth;
      SvgUtils.drawText(this.snapCanvas, {
        x: center.x,
        y: center.y - this.hexHeight / 2 + (this.hexHeight * .14)
      }, city.name, this.controller.getLabelStyle());
      boxWidth = this.hexWidth * .35;
      boxHeight = this.hexHeight * .3;
      SvgUtils.drawCenteredRectangle(this.snapCanvas, {
        x: center.x,
        y: center.y + this.hexHeight / 3.4
      }, boxWidth, boxHeight, {
        stroke: "black",
        fill: "white"
      });
      border = this.paintThickBorder(col, row, 5);
      return border.attr("class", "hex_outlines");
    };

    BoardRenderer.prototype.clearHexAt = function(col, row) {
      return $("#boardhex_" + col + "_" + row).remove();
    };

    BoardRenderer.prototype.renderHexAt = function(col, row, hexData) {
      var center, centerX, centerY, cube, hex, nub, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      if (hexData.reset) {
        this.clearHexAt(col, row);
      }
      console.log("renderHexAt [" + col + "," + row + "]");
      center = this.getHexPosition(col, row);
      centerX = center.x;
      centerY = center.y;
      hex = SvgUtils.drawHex(this.snapCanvas, center, this.getHexSize(), this.controller.getStyleForHexType(hexData));
      hex.attr("id", "boardhex_" + col + "_" + row);
      if (hexData.type === HexData.TYPE_TOWN) {
        this.renderTown(center, hexData.town);
      }
      if (hexData.type === HexData.TYPE_CITY) {
        this.renderCity(center, col, row, hexData.city);
      }
      if (hexData.nubs !== void 0 && hexData.nubs.length > 0) {
        _ref = hexData.nubs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          nub = _ref[_i];
          this.drawTrackNub(col, row, nub.sideA, nub.sideB);
        }
      }
      if (hexData.previewNubs !== void 0 && hexData.previewNubs.length > 0) {
        _ref1 = hexData.previewNubs;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          nub = _ref1[_j];
          this.drawTrackNub(col, row, nub.sideA, nub.sideB, "blue");
        }
      }
      if (hexData.cubes !== void 0 && hexData.cubes.length > 0) {
        _ref2 = hexData.cubes;
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          cube = _ref2[_k];
          _results.push(this.drawCube(center, col, row, cube));
        }
        return _results;
      }
    };

    return BoardRenderer;

  })();

  window.TileBank = (function() {
    function TileBank(controller) {
      this.controller = controller;
      $("#tileChooserDialog").dialog({
        title: "Pick a tile",
        autoOpen: false,
        width: 380,
        height: 150,
        modal: false
      });
      $("#tileChooserLauncher").click(function() {
        return $("#tileChooserDialog").dialog("open");
      });
      $("#tileRotater #leftRot").click((function(_this) {
        return function() {
          return _this.controller.handleTileBankPreviewRotation(-1);
        };
      })(this));
      $("#tileRotater #rightRot").click((function(_this) {
        return function() {
          return _this.controller.handleTileBankPreviewRotation(1);
        };
      })(this));
      $("#tileRotater #okTile").click((function(_this) {
        return function() {
          return _this.controller.handleTileBankOk();
        };
      })(this));
      $("#tileRotater #cancelTile").click((function(_this) {
        return function() {
          return _this.controller.handleTileBankCancel();
        };
      })(this));
    }

    TileBank.prototype.hideRotationUi = function() {
      return $("#tileRotater").css("display", "none");
    };

    TileBank.prototype.showRotationUi = function(coords, size) {
      var rotateUi;
      rotateUi = $("#tileRotater");
      rotateUi.width(size).height(size);
      return rotateUi.css({
        display: "block",
        left: coords.x - rotateUi.width() / 2.2,
        top: coords.y - rotateUi.height() / 2.2
      });
    };

    TileBank.prototype.initUi = function(tileSize) {
      var ctrl, nub, pd, pickerData, tempRenderer, _i, _j, _len, _len1, _ref, _results;
      pickerData = [
        {
          id: "straightPicker",
          nubs: [
            {
              a: 1,
              b: 4
            }
          ]
        }, {
          id: "gentlePicker",
          nubs: [
            {
              a: 1,
              b: 3
            }
          ]
        }, {
          id: "sharpPicker",
          nubs: [
            {
              a: 1,
              b: 2
            }
          ]
        }, {
          id: "crossPicker",
          nubs: [
            {
              a: 5,
              b: 3
            }, {
              a: 1,
              b: 4
            }
          ]
        }
      ];
      _results = [];
      for (_i = 0, _len = pickerData.length; _i < _len; _i++) {
        pd = pickerData[_i];
        tempRenderer = new BoardRenderer(this.controller, pd.id);
        tempRenderer.setHexSize(tileSize);
        tempRenderer.SIDE_PADDING = 0;
        tempRenderer.renderHexAt(0, 0, {
          type: HexData.TYPE_NORMAL
        });
        _ref = pd.nubs;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          nub = _ref[_j];
          tempRenderer.drawTrackNub(0, 0, nub.a, nub.b);
        }
        $("#" + pd.id).attr("nubData", JSON.stringify(pd.nubs));
        ctrl = this.controller;
        $("#" + pd.id).draggable({
          containment: "#gameboard",
          appendTo: "body",
          helper: "clone",
          start: (function() {
            console.log("start drag!");
            return $("#tileChooserDialog").dialog("close");
          }),
          stop: (function(evt) {
            var svgOffset, svgX, svgY;
            svgOffset = $("#gameboard").offset();
            svgX = evt.pageX - svgOffset.left;
            svgY = evt.pageY - svgOffset.top;
            console.log("stop!");
            console.log($(this).attr("nubData"));
            return ctrl.handleTileBankHexDrop(svgX, svgY, JSON.parse($(this).attr("nubData")));
          }),
          drag: ((function(_this) {
            return function(evt) {
              var svgOffset, svgX, svgY;
              svgOffset = $("#gameboard").offset();
              svgX = evt.pageX - svgOffset.left;
              svgY = evt.pageY - svgOffset.top;
              return _this.controller.findCoords(svgX, svgY);
            };
          })(this))
        });
        $("#" + pd.id).height(tempRenderer.hexHeight);
        _results.push($("#" + pd.id).width(tempRenderer.hexWidth));
      }
      return _results;
    };

    return TileBank;

  })();

}).call(this);
